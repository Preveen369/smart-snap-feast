/**
 * GeminiImageService - Advanced AI-powered recipe image generation service
 * 
 * Integrates with Google Gemini 2.0 Flash for creating high-quality, contextual
 * food photography based on recipe titles and ingredient combinations. Provides
 * multiple styling options, error handling, and fallback mechanisms for robust
 * image generation in culinary applications.
 * 
 * @class GeminiImageService
 */

import { GoogleGenAI, Modality } from '@google/genai';

/**
 * Configuration options for Gemini image generation
 * 
 * @interface GeminiImageOptions
 * @property style - Visual style preference for generated food photography
 * @property quality - Image quality setting affecting resolution and detail
 * @property format - Output image format for web optimization
 */
export interface GeminiImageOptions {
  style?: 'food-photography' | 'minimalist' | 'rustic' | 'elegant';
  quality?: 'standard' | 'high';
  format?: 'webp' | 'png' | 'jpg';
}

export class GeminiImageService {
  // Google Generative AI client instance for API communication
  private client: GoogleGenAI;
  
  /**
   * Initializes Gemini AI service with API key validation
   * 
   * Sets up Google Generative AI client with environment-based configuration.
   * Validates API key presence and provides user-friendly error messaging
   * for configuration issues.
   * 
   * @throws Error if Gemini API key is not configured in environment
   */
  constructor() {
    const apiKey = import.meta.env.VITE_GEMINI_API_KEY;
    
    if (!apiKey) {
      throw new Error('🔑 Gemini API key not configured. Please add VITE_GEMINI_API_KEY to your .env file.');
    }
    
    this.client = new GoogleGenAI({
      apiKey: apiKey
    });
  }

  /**
   * Generates contextual recipe images using Gemini 2.0 Flash AI
   * 
   * Creates professional-quality food photography based on recipe context,
   * ingredient composition, and styling preferences. Utilizes advanced AI
   * image generation with comprehensive error handling and response processing.
   * 
   * @param recipeTitle - Recipe name for contextual image generation
   * @param ingredients - Array of ingredient names for visual reference
   * @param options - Styling and quality configuration options
   * @returns Promise resolving to base64 data URL of generated image
   * @throws Error with specific messaging for various failure scenarios
   */
  async generateRecipeImage(
    recipeTitle: string, 
    ingredients: string[], 
    options: GeminiImageOptions = {}
  ): Promise<string> {
    try {
      console.log('🎨 Generating recipe image with Gemini for:', recipeTitle);
      
      // Create contextually rich prompt for optimal food image generation
      const prompt = this.createImagePrompt(recipeTitle, ingredients, options);
      
      console.log('📝 Using prompt:', prompt);
      
      // Request AI image generation with multimodal response configuration
      const response = await this.client.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt.trim(),
        config: {
          responseModalities: [Modality.TEXT, Modality.IMAGE],
        }
      });

      // Validate response structure and extract image data
      if (!response?.candidates?.[0]?.content?.parts) {
        throw new Error('No image generated by Gemini API');
      }

      // Process response parts to locate and extract image data
      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
          // Convert AI-generated image data to web-ready data URL format
          const imageData = part.inlineData.data;
          const mimeType = part.inlineData.mimeType || 'image/png';
          const dataUrl = `data:${mimeType};base64,${imageData}`;
          
          console.log('✅ Gemini image generated successfully');
          return dataUrl;
        }
      }

      throw new Error('No image data found in Gemini response');
      
    } catch (error) {
      console.error('❌ Gemini image generation failed:', error);
      
      // Transform technical errors into user-friendly messages for web interface
      if (error instanceof Error) {
        const msg = error.message.toLowerCase();
        
        if (msg.includes('api key') || msg.includes('authentication')) {
          throw new Error('🔐 Invalid Gemini API key. Please check your VITE_GEMINI_API_KEY in .env file.');
        }
        if (msg.includes('rate limit') || msg.includes('429')) {
          throw new Error('⏳ Gemini API rate limit reached. Please wait and try again.');
        }
        if (msg.includes('network') || msg.includes('fetch')) {
          throw new Error('🌐 Network error connecting to Gemini API. Please check your internet connection.');
        }
        if (msg.includes('quota') || msg.includes('billing')) {
          throw new Error('💳 Gemini API quota exceeded. Please check your billing settings.');
        }
      }
      
      // Preserve original error context for debugging while providing user context
      throw new Error(`Gemini image generation failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Creates comprehensive, style-aware prompts for optimal food photography
   * 
   * Constructs detailed AI prompts incorporating recipe context, ingredient
   * information, and visual styling preferences to generate appetizing,
   * professional-quality food images suitable for culinary applications.
   * 
   * @param recipeTitle - Recipe name for contextual relevance
   * @param ingredients - Ingredient list for visual composition guidance
   * @param options - Styling preferences and quality settings
   * @returns Detailed prompt string optimized for food image generation
   * @private
   */
  private createImagePrompt(
    recipeTitle: string, 
    ingredients: string[], 
    options: GeminiImageOptions
  ): string {
    const style = options.style || 'food-photography';
    const quality = options.quality || 'high';
    
    // Construct base prompt with recipe context for accurate representation
    const basePrompt = `Create a professional ${style} style image of "${recipeTitle}"`;
    
    // Include key ingredients for visual authenticity and composition guidance
    const ingredientContext = ingredients.length > 0 
      ? ` featuring visible ${ingredients.slice(0, 3).join(', ')}` 
      : '';
    
    // Comprehensive style descriptions for consistent visual aesthetics
    const styleDescriptions = {
      'food-photography': 'with professional lighting, shallow depth of field, and appetizing presentation on a clean white or wooden surface',
      'minimalist': 'with clean, simple composition, neutral colors, and minimal props on a plain background',
      'rustic': 'with warm, natural lighting, wooden textures, and homestyle presentation with rustic tableware',
      'elegant': 'with sophisticated plating, fine dining presentation, and elegant garnishing on premium dinnerware'
    };
    
    // Quality specifications for appropriate resolution and detail levels
    const qualityDescriptor = quality === 'high' 
      ? 'Ultra-high quality, 4K resolution, restaurant-quality presentation' 
      : 'High quality, professional presentation';
    
    return `${basePrompt}${ingredientContext}. ${styleDescriptions[style]}. ${qualityDescriptor}. The dish should look fresh, delicious, and inviting. Avoid any text, logos, or watermarks in the image.`;
  }

  /**
   * Generates multiple stylistic variations of recipe images
   * 
   * Creates diverse visual interpretations of the same recipe using different
   * artistic styles. Provides options for A/B testing, user preference selection,
   * and enhanced visual variety in recipe presentations.
   * 
   * @param recipeTitle - Recipe name for consistent context across variations
   * @param ingredients - Ingredient list for visual consistency
   * @param count - Number of variations to generate (max 3)
   * @returns Promise resolving to array of generated image URLs
   * @throws Error if all variation generation attempts fail
   */
  async generateImageVariations(
    recipeTitle: string,
    ingredients: string[],
    count: number = 3
  ): Promise<string[]> {
    // Predefined style collection for diverse visual interpretations
    const styles: GeminiImageOptions['style'][] = ['food-photography', 'minimalist', 'elegant'];
    const promises = styles.slice(0, count).map(style => 
      this.generateRecipeImage(recipeTitle, ingredients, { style })
    );
    
    try {
      // Execute parallel generation with error isolation for partial success
      const results = await Promise.allSettled(promises);
      return results
        .filter(result => result.status === 'fulfilled')
        .map(result => (result as PromiseFulfilledResult<string>).value);
    } catch (error) {
      console.error('Failed to generate image variations:', error);
      throw error;
    }
  }

  /**
   * Validates Gemini API configuration status
   * 
   * Performs runtime check for proper API key configuration to enable
   * graceful feature degradation when Gemini services are unavailable.
   * 
   * @returns true if API key is properly configured for service usage
   */
  isConfigured(): boolean {
    return !!import.meta.env.VITE_GEMINI_API_KEY;
  }
}

// Export singleton instance for application-wide Gemini image service access
export const geminiService = new GeminiImageService();